from abc import ABC, abstractmethod
import pickle
import zstd
import os
import socket
import threading
import time
import base64

class Object(ABC):
    """
    Abstract base class for objects that can save and load their state.
    Provides a generic interface for persistence operations.
    """

    def __init__(self, default_value=None):
        self._data = None

        # Try to load existing data, otherwise use default
        try:
            self.load()
        except (FileNotFoundError, ConnectionError, Exception):
            self._data = default_value if default_value is not None else {}
            self.save()

    @abstractmethod
    def save(self):
        """Save the object's data. Must be implemented by subclasses."""
        pass

    @abstractmethod
    def load(self):
        """Load the object's data. Must be implemented by subclasses."""
        pass

    # Dict-like interface
    def __getitem__(self, key):
        return self._data[key]

    def __setitem__(self, key, value):
        self._data[key] = value
        self.save()

    def __delitem__(self, key):
        del self._data[key]
        self.save()

    def __contains__(self, key):
        return key in self._data

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)

    def keys(self):
        return self._data.keys() if hasattr(self._data, 'keys') else None

    def values(self):
        return self._data.values() if hasattr(self._data, 'values') else None

    def items(self):
        return self._data.items() if hasattr(self._data, 'items') else None

    def get(self, key, default=None):
        return self._data.get(key, default) if hasattr(self._data, 'get') else default

    def update(self, other):
        if hasattr(self._data, 'update'):
            self._data.update(other)
            self.save()

    # List-like interface
    def append(self, item):
        if hasattr(self._data, 'append'):
            self._data.append(item)
            self.save()

    def extend(self, items):
        if hasattr(self._data, 'extend'):
            self._data.extend(items)
            self.save()

    def insert(self, index, item):
        if hasattr(self._data, 'insert'):
            self._data.insert(index, item)
            self.save()

    def remove(self, item):
        if hasattr(self._data, 'remove'):
            self._data.remove(item)
            self.save()

    def pop(self, index=-1):
        if hasattr(self._data, 'pop'):
            result = self._data.pop(index)
            self.save()
            return result

    def index(self, item, start=0, end=None):
        if hasattr(self._data, 'index'):
            return self._data.index(item, start, end)

    def count(self, item):
        if hasattr(self._data, 'count'):
            return self._data.count(item)

    # General object interface
    def __getattr__(self, name):
        # Delegate to the underlying data object
        if hasattr(self._data, name):
            attr = getattr(self._data, name)
            if callable(attr):
                # Wrap methods to save after modification
                def wrapper(*args, **kwargs):
                    result = attr(*args, **kwargs)
                    self.save()
                    return result
                return wrapper
            return attr
        raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")

    def __setattr__(self, name, value):
        # Handle internal attributes and specific object attributes
        if name.startswith('_') or name in ('path', 'host', 'port', 'timeout', 'compression_level'):
            super().__setattr__(name, value)
        else:
            # Set attribute on underlying data
            if hasattr(self, '_data') and self._data is not None:
                setattr(self._data, name, value)
                self.save()
            else:
                super().__setattr__(name, value)

    def __str__(self):
        return str(self._data)

    def __repr__(self):
        return f"{type(self).__name__}(data={repr(self._data)})"

    def __eq__(self, other):
        if isinstance(other, Object):
            return self._data == other._data
        return self._data == other

    # Context manager support
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.save()

class DiskObject(Object):
    """
    A object that mirrors its state to a file and loads it on creation.
    Supports dict-like, list-like, and general object behavior.
    """

    def __init__(self, path, default_value=None):
        self.path = path
        super().__init__(default_value)

    def load(self):
        """Load data from disk"""
        try:
            with open(self.path, 'rb') as f:
                self._data = self._deserialize(f.read())
        except (FileNotFoundError, EOFError, pickle.UnpicklingError):
            self._data = {}

    def save(self):
        """Save data to disk"""
        os.makedirs(os.path.dirname(self.path), exist_ok=True)
        with open(self.path, 'wb') as f:
            f.write(self._serialize(self._data))

    def _serialize(self, data):
        """Serialize data - can be overridden by subclasses"""
        return pickle.dumps(data)

    def _deserialize(self, data):
        """Deserialize data - can be overridden by subclasses"""
        return pickle.loads(data)

    def __repr__(self):
        return f"{type(self).__name__}(path='{self.path}', data={repr(self._data)})"

class CompressedDiskObject(DiskObject):
    """
    A DiskObject that compresses its data using zstd with compression level 5.
    """

    def __init__(self, path, default_value=None, compression_level=5):
        # Set compression_level as a private attribute first to avoid recursion
        object.__setattr__(self, 'compression_level', compression_level)
        super().__init__(path, default_value)

    def _serialize(self, data):
        """Serialize and compress data"""
        pickled_data = pickle.dumps(data)
        return zstd.compress(pickled_data, self.compression_level)

    def _deserialize(self, data):
        """Decompress and deserialize data"""
        decompressed_data = zstd.decompress(data)
        return pickle.loads(decompressed_data)

class NetworkObject(Object):
    """
    A distributed object that synchronizes state across multiple instances in real-time.
    Uses a simple TCP protocol: "DATA:<pickled_data>\n" messages.
    One instance acts as server, others as clients. All stay connected for real-time sync.
    """

    def __init__(self, host, port=None, default_value=None, timeout=30):
        import threading
        
        if isinstance(host, str) and ':' in host and port is None:
            # Parse host:port format
            host, port = host.rsplit(':', 1)
            port = int(port)
        elif port is None:
            raise ValueError("Port must be specified either as separate argument or in host:port format")
        
        self.host = host
        self.port = int(port)
        self.timeout = timeout
        self._server_socket = None
        self._client_connections = {}  # {socket: address}
        self._lock = threading.Lock()  # Thread-safe access to connections
        self._client_lock = threading.Lock()  # Thread-safe access to client socket
        self._server_thread = None
        self._client_socket = None
        self._is_server = False
        self._update_callbacks = []
        self._reconnect_attempts = 0
        self._max_reconnect_attempts = 5
        
        # Initialize _data first to avoid recursion
        self._data = None
        
        # Try to connect as client first
        try:
            self._connect_as_client()
            self.load()
        except (FileNotFoundError, ConnectionError, Exception):
            self._data = default_value if default_value is not None else {}

    def _connect_as_client(self):
        """Connect to server as a client and subscribe to updates with retry logic"""
        import socket
        import threading
        import time
        
        if self._client_socket:
            try:
                self._client_socket.close()
            except:
                pass
        
        max_attempts = 3
        for attempt in range(max_attempts):
            try:
                self._client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self._client_socket.settimeout(self.timeout)
                self._client_socket.connect((self.host, self.port))
                
                # Subscribe to updates
                self._client_socket.sendall(b"SUBSCRIBE\n")
                
                # Wait for subscription ACK
                try:
                    self._client_socket.settimeout(5.0)
                    ack_line = b''
                    while not ack_line.endswith(b'\n'):
                        chunk = self._client_socket.recv(1)
                        if not chunk:
                            raise ConnectionError("Server closed connection during subscription")
                        ack_line += chunk
                    
                    if ack_line.strip() != b'ACK':
                        raise ConnectionError(f"Unexpected subscription response: {ack_line.strip()}")
                        
                    self._client_socket.settimeout(None)
                except Exception as sub_error:
                    if self._client_socket:
                        try:
                            self._client_socket.close()
                        except:
                            pass
                        self._client_socket = None
                    raise ConnectionError(f"Subscription failed: {sub_error}")
                
                # Start thread to listen for updates
                update_thread = threading.Thread(target=self._listen_for_updates, daemon=True)
                update_thread.start()
                
                self._reconnect_attempts = 0
                return
                
            except Exception as e:
                if self._client_socket:
                    try:
                        self._client_socket.close()
                    except:
                        pass
                    self._client_socket = None
                
                if attempt < max_attempts - 1:
                    time.sleep(0.5 * (attempt + 1))  # Exponential backoff
                else:
                    raise ConnectionError(f"Failed to connect after {max_attempts} attempts: {e}")

    def _listen_for_updates(self):
        """Listen for updates from server with improved reliability"""
        import struct
        import socket
        import time
        
        def read_line(sock, timeout=10):
            """Read a line from socket with timeout"""
            sock.settimeout(timeout)
            line = b''
            try:
                while not line.endswith(b'\n'):
                    chunk = sock.recv(1)
                    if not chunk:
                        return None
                    line += chunk
                return line.strip()
            except socket.timeout:
                return None
            finally:
                sock.settimeout(None)
        
        def read_exact(sock, n, timeout=10):
            """Read exact number of bytes from socket"""
            sock.settimeout(timeout)
            data = b''
            try:
                while len(data) < n:
                    chunk = sock.recv(n - len(data))
                    if not chunk:
                        return None
                    data += chunk
                return data
            except socket.timeout:
                return None
            finally:
                sock.settimeout(None)
        
        try:
            while not self._is_server:
                with self._client_lock:
                    client_socket = self._client_socket
                
                if not client_socket:
                    break
                
                try:
                    # Read command with timeout
                    command_line = read_line(client_socket)
                    if not command_line:
                        print("Connection lost, attempting to reconnect...")
                        if not self._attempt_reconnect():
                            break
                        continue
                    
                    # Safe decode with error handling
                    try:
                        command = command_line.decode('utf-8', errors='replace')
                    except Exception as decode_error:
                        print(f"Failed to decode command: {decode_error}")
                        continue
                    
                    if command == 'UPDATE':
                        # Read data length
                        len_data = read_exact(client_socket, 4)
                        if not len_data:
                            continue
                        
                        data_len = struct.unpack('>I', len_data)[0]
                        
                        # Sanity check data length
                        if data_len > 10 * 1024 * 1024:  # 10MB max
                            print(f"Warning: Large data packet ({data_len} bytes), skipping")
                            continue
                        
                        # Read data with timeout
                        data = read_exact(client_socket, data_len, timeout=30)
                        if not data:
                            continue
                        
                        # Update local data
                        try:
                            new_data = pickle.loads(data)
                            if new_data != self._data:
                                self._data = new_data
                                # Trigger callbacks for live updates
                                for callback in self._update_callbacks:
                                    try:
                                        callback(self._data)
                                    except Exception as callback_error:
                                        print(f"Callback error: {callback_error}")
                        except (pickle.UnpicklingError, EOFError) as pickle_error:
                            print(f"Failed to deserialize update: {pickle_error}")
                            continue
                        except Exception as e:
                            print(f"Unexpected error during data update: {e}")
                            continue
                        
                        # No ACK needed for UPDATE messages
                        
                except Exception as e:
                    print(f"Error in update listener: {e}")
                    if self._reconnect_attempts < self._max_reconnect_attempts:
                        time.sleep(1)
                        self._attempt_reconnect()
                    else:
                        print("Max reconnection attempts reached, giving up")
                        break
                        
        except Exception as e:
            print(f"Fatal error in update listener: {e}")
        finally:
            if self._client_socket:
                try:
                    self._client_socket.close()
                except:
                    pass
                self._client_socket = None

    def _attempt_reconnect(self):
        """Attempt to reconnect to server"""
        if self._reconnect_attempts >= self._max_reconnect_attempts:
            return False
        
        self._reconnect_attempts += 1
        try:
            print(f"Reconnection attempt {self._reconnect_attempts}/{self._max_reconnect_attempts}")
            with self._client_lock:
                self._connect_as_client()
            return True
        except Exception as e:
            print(f"Reconnection failed: {e}")
            return False

    def _broadcast_update(self, data):
        """Broadcast update to all connected clients with improved reliability"""
        import struct
        
        if not self._is_server:
            return
            
        pickled_data = pickle.dumps(data)
        message = b"UPDATE\n" + struct.pack('>I', len(pickled_data)) + pickled_data
        
        # Send to all connected clients with better error handling
        disconnected = []
        for client_socket, address in list(self._client_connections.items()):
            try:
                # Send message
                client_socket.sendall(message)
                
                # Wait for ACK with reasonable timeout
                client_socket.settimeout(5.0)
                ack_response = b''
                while len(ack_response) < 4:
                    chunk = client_socket.recv(4 - len(ack_response))
                    if not chunk:
                        raise ConnectionError("Client disconnected during ACK")
                    ack_response += chunk
                
                if ack_response not in (b"ACK\n", b'CK\n'):  # Handle partial ACK
                    print(f"Warning: Unexpected ACK from {address}: {ack_response}")
                    
                client_socket.settimeout(None)
                
            except Exception as e:
                print(f"Failed to send update to client {address}: {e}")
                disconnected.append(client_socket)
        
        # Remove disconnected clients
        for client_socket in disconnected:
            if client_socket in self._client_connections:
                addr = self._client_connections[client_socket]
                print(f"Removing disconnected client: {addr}")
                del self._client_connections[client_socket]
                try:
                    client_socket.close()
                except:
                    pass

    def _handle_client(self, client_socket, address):
        """Handle a client connection on the server"""
        import struct
        import socket
        
        def safe_recv_line(sock):
            """Safely receive a line from socket"""
            try:
                original_timeout = sock.gettimeout()
                sock.settimeout(5.0)
                line = b''
                while not line.endswith(b'\n'):
                    try:
                        chunk = sock.recv(1)
                        if not chunk:
                            return None
                        line += chunk
                    except socket.error as e:
                        if e.errno == 9:  # Bad file descriptor
                            return None
                        raise
                return line.strip()
            except (socket.timeout, socket.error, OSError) as e:
                print(f"safe_recv_line error: {e}")
                return None
            finally:
                try:
                    sock.settimeout(original_timeout)
                except:
                    pass
        
        def safe_recv_exact(sock, n):
            """Safely receive exact number of bytes"""
            try:
                original_timeout = sock.gettimeout()
                sock.settimeout(10.0)
                data = b''
                while len(data) < n:
                    try:
                        chunk = sock.recv(n - len(data))
                        if not chunk:
                            return None
                        data += chunk
                    except socket.error as e:
                        if e.errno == 9:  # Bad file descriptor
                            return None
                        raise
                return data
            except (socket.timeout, socket.error, OSError) as e:
                print(f"safe_recv_exact error: {e}")
                return None
            finally:
                try:
                    sock.settimeout(original_timeout)
                except:
                    pass
        
        try:
            while True:
                # Read command with safe handling
                command_line = safe_recv_line(client_socket)
                if not command_line:
                    break
                
                try:
                    command = command_line.decode('utf-8', errors='replace')
                except Exception:
                    continue
                
                if command == 'SUBSCRIBE':
                    # Add client to connections and send current data
                    try:
                        with self._lock:  # Thread-safe connection management
                            self._client_connections[client_socket] = address
                        
                        # Send immediate ACK for subscription
                        try:
                            client_socket.sendall(b"ACK\n")
                            print(f"Client {address} successfully subscribed")
                        except Exception as ack_error:
                            print(f"Failed to send subscription ACK to {address}: {ack_error}")
                            with self._lock:
                                if client_socket in self._client_connections:
                                    del self._client_connections[client_socket]
                            break
                        
                        # Then send current data as an update
                        pickled_data = pickle.dumps(self._data)
                        message = b"UPDATE\n" + struct.pack('>I', len(pickled_data)) + pickled_data
                        try:
                            client_socket.sendall(message)
                        except Exception as update_error:
                            print(f"Failed to send initial data to {address}: {update_error}")
                            
                    except Exception as e:
                        print(f"Error handling SUBSCRIBE from {address}: {e}")
                        # Remove from connections if subscription failed
                        with self._lock:
                            if client_socket in self._client_connections:
                                del self._client_connections[client_socket]
                        break
                    
                elif command == 'SYNC':
                    # Client is sending updated data
                    len_data = safe_recv_exact(client_socket, 4)
                    if not len_data:
                        continue
                    
                    data_len = struct.unpack('>I', len_data)[0]
                    
                    # Sanity check data length
                    if data_len > 10 * 1024 * 1024:  # 10MB max
                        print(f"Client {address} sent oversized data ({data_len} bytes), skipping")
                        continue
                    
                    # Read data safely
                    data = safe_recv_exact(client_socket, data_len)
                    if not data:
                        continue
                    
                    try:
                        # Update server data and broadcast to other clients (not sender)
                        self._data = pickle.loads(data)
                        
                        # Broadcast to all OTHER clients (exclude sender)
                        pickled_data = pickle.dumps(self._data)
                        message = b"UPDATE\n" + struct.pack('>I', len(pickled_data)) + pickled_data
                        
                        disconnected = []
                        with self._lock:  # Thread-safe access to connections
                            clients_list = list(self._client_connections.items())
                        
                        for other_socket, other_address in clients_list:
                            if other_socket != client_socket:  # Don't send back to sender
                                try:
                                    # Check if socket is still valid before sending
                                    other_socket.getpeername()  # This will raise exception if socket is closed
                                    other_socket.sendall(message)
                                    print(f"Broadcasted update to client {other_address}")
                                        
                                except (socket.error, OSError) as broadcast_error:
                                    print(f"Socket error broadcasting to {other_address}: {broadcast_error}")
                                    disconnected.append(other_socket)
                                except Exception as broadcast_error:
                                    print(f"Failed to broadcast to {other_address}: {broadcast_error}")
                                    disconnected.append(other_socket)
                        
                        # Remove disconnected clients (thread-safe)
                        with self._lock:
                            for disc_socket in disconnected:
                                if disc_socket in self._client_connections:
                                    del self._client_connections[disc_socket]
                                    try:
                                        disc_socket.close()
                                    except:
                                        pass
                        
                        # Send ACK to the sender
                        try:
                            client_socket.sendall(b"ACK\n")
                        except Exception as ack_error:
                            print(f"Failed to send ACK to {address}: {ack_error}")
                            break
                            
                    except (pickle.UnpicklingError, EOFError) as pickle_error:
                        print(f"Failed to deserialize data from {address}: {pickle_error}")
                        continue
                    except Exception as sync_error:
                        print(f"Error handling SYNC from {address}: {sync_error}")
                        break
                    
        except Exception as e:
            print(f"Error handling client {address}: {e}")
        finally:
            # Clean up client connection
            with self._lock:  # Thread-safe cleanup
                if client_socket in self._client_connections:
                    del self._client_connections[client_socket]
            try:
                client_socket.shutdown(socket.SHUT_RDWR)
            except:
                pass
            try:
                client_socket.close()
            except:
                pass

    def serve(self):
        """Start serving as the NetworkObject server"""
        import socket
        import threading
        
        if self._is_server:
            return  # Already serving
            
        self._is_server = True
        
        # Close client connection if exists
        if self._client_socket:
            self._client_socket.close()
            self._client_socket = None
        
        # Start server
        self._server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self._server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self._server_socket.bind((self.host, self.port))
        self._server_socket.listen(5)

        while self._server_socket:
            try:
                client_socket, address = self._server_socket.accept()
                client_thread = threading.Thread(
                    target=self._handle_client,
                    args=(client_socket, address),
                    daemon=True
                )
                client_thread.start()
            except Exception:
                break

    def load(self):
        """Load is handled automatically via server sync - no-op for clients"""
        pass

    def save(self):
        """Save data by syncing with server or broadcasting if server - improved reliability"""
        import socket
        import struct
        import time
        
        if self._is_server:
            # Server broadcasts to all clients
            self._broadcast_update(self._data)
        else:
            # Client sends sync to server with retry logic
            max_attempts = 3
            for attempt in range(max_attempts):
                with self._client_lock:
                    client_socket = self._client_socket
                
                if not client_socket:
                    # Try to reconnect
                    try:
                        with self._client_lock:
                            # Double-check after acquiring lock
                            if not self._client_socket:
                                self._connect_as_client()
                            client_socket = self._client_socket
                    except Exception as e:
                        if attempt == max_attempts - 1:
                            raise ConnectionError(f"Failed to reconnect: {e}")
                        time.sleep(1.0 * (attempt + 1))  # Longer backoff
                        continue
                
                if not client_socket:
                    raise ConnectionError("Client socket is None")
                
                try:
                    pickled_data = pickle.dumps(self._data)
                    message = b"SYNC\n" + struct.pack('>I', len(pickled_data)) + pickled_data
                    client_socket.sendall(message)
                    
                    # Read ACK response using safe helper function
                    def safe_read_ack(sock, timeout=10.0):
                        """Safely read ACK from socket"""
                        try:
                            original_timeout = sock.gettimeout()
                            sock.settimeout(timeout)
                            ack_line = b''
                            while not ack_line.endswith(b'\n'):
                                chunk = sock.recv(1)
                                if not chunk:
                                    return None
                                ack_line += chunk
                            return ack_line.strip()
                        except (socket.timeout, socket.error, OSError):
                            return None
                        finally:
                            try:
                                sock.settimeout(original_timeout)
                            except:
                                pass
                    
                    ack_response = safe_read_ack(client_socket)
                    if not ack_response:
                        raise ConnectionError("Server disconnected during ACK")
                    
                    if ack_response == b'ACK':
                        return  # Success
                    else:
                        raise ConnectionError(f"Invalid server response: {ack_response}")
                    
                except Exception as e:
                    print(f"Sync attempt {attempt + 1} failed: {e}")
                    
                    # Close connection on failure
                    with self._client_lock:
                        if self._client_socket:
                            try:
                                self._client_socket.close()
                            except:
                                pass
                            self._client_socket = None
                    
                    if attempt == max_attempts - 1:
                        raise ConnectionError(f"Failed to sync after {max_attempts} attempts: {e}")
                    else:
                        time.sleep(0.5 * (attempt + 1))  # Exponential backoff

    def add_update_callback(self, callback):
        """Add a callback function to be called when data is updated"""
        self._update_callbacks.append(callback)

    def remove_update_callback(self, callback):
        """Remove an update callback"""
        if callback in self._update_callbacks:
            self._update_callbacks.remove(callback)

    def close(self):
        """Close all connections"""
        if self._server_socket:
            self._server_socket.close()
            self._server_socket = None
        
        if self._client_socket:
            self._client_socket.close()
            self._client_socket = None
        
        for client_socket in list(self._client_connections.keys()):
            client_socket.close()
        self._client_connections.clear()

    def __repr__(self):
        role = "server" if self._is_server else "client"
        return f"{type(self).__name__}({role} at {self.host}:{self.port}, data={repr(self._data)})"


__all__ = ['Object', 'DiskObject', 'CompressedDiskObject', 'NetworkObject']
