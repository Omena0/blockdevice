name: Build

on: push

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

permissions:
  contents: read

jobs:
  ensure-tag:
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.pypi_check.outputs.should_build }}
      version_exists: ${{ steps.pypi_check.outputs.version_exists }}
      candidate_version: ${{ steps.pypi_check.outputs.version }}
      # blockdevice_version and release_display_name are computed in the build job
      # to keep version logic centralized in scripts/get_version.py
    # This job needs write permissions to push tags back to the repository
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure release has a tag
        id: ensure_tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          RELEASE_TAG="${{ github.event.release.tag_name }}"
          echo "Release tag (from event): '$RELEASE_TAG'"

          if [ -n "$RELEASE_TAG" ]; then
            echo "Release already has tag: $RELEASE_TAG"
            echo "should_build=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Reuse the same detection logic the later step uses to find a candidate
          FOUND=0
          TAG=""
          for commit in $(git rev-list --max-count=200 HEAD); do
            msg=$(git log -1 --pretty=%B "$commit" | sed -n '1p' | tr -d '\r')
            if echo "$msg" | grep -q "-"; then
              candidate=$(echo "$msg" | cut -d'-' -f1 | tr -d '[:space:]')
              if echo "$candidate" | grep -E -q '^[0-9]+[A-Za-z]?$'; then
                FOUND=1
                TAG="$candidate"
                break
              fi
            fi
          done

          if [ "$FOUND" -eq 0 ]; then
            echo "No matching commit found; should_build=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Found tag candidate from commits: $TAG"

          # Push tag only if it doesn't exist remotely
          if git ls-remote --tags origin "refs/tags/$TAG" | grep -q "$TAG"; then
            echo "Tag $TAG already exists on remote"
          else
            echo "Creating tag: $TAG"
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git tag -a "$TAG" -m "Tag for release $TAG"
            git push origin "refs/tags/$TAG"
          fi
          echo "should_build=true" >> "$GITHUB_OUTPUT"
          # Export the chosen tag as a step output so later steps can use it
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Detect release candidate in commits
        id: detect
        run: |
          set -euo pipefail
          # If CI explicitly sets BLOCKDEVICE_VERSION, build
          if [ -n "${BLOCKDEVICE_VERSION-}" ]; then
            echo "should_build=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          FOUND=0
          CANDIDATE=""
          for commit in $(git rev-list --max-count=200 HEAD); do
            msg=$(git log -1 --pretty=%B "$commit" | sed -n '1p' | tr -d '\r')
            if echo "$msg" | grep -q "-"; then
              candidate=$(echo "$msg" | cut -d'-' -f1 | tr -d '[:space:]')
              if echo "$candidate" | grep -E -q '^[0-9]+[A-Za-z]?$'; then
                FOUND=1
                CANDIDATE="$candidate"
                break
              fi
            fi
          done
          if [ "$FOUND" -eq 1 ]; then
            echo "candidate=$CANDIDATE" >> "$GITHUB_OUTPUT"
            echo "should_build=true" >> "$GITHUB_OUTPUT"
          else
            echo "should_build=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Check if version already exists on PyPI
        id: pypi_check
        if: steps.detect.outputs.should_build == 'true'
        run: |
          set -euo pipefail
          
          # Convert candidate to version number using same logic as get_version.py
          CANDIDATE="${{ steps.detect.outputs.candidate }}"
          
          # Extract major version (digits)
          MAJOR=$(echo "$CANDIDATE" | sed -E 's/([0-9]+).*/\1/')
          
          # Extract letter and convert to minor version (A=0, B=1, etc.)
          LETTER=$(echo "$CANDIDATE" | sed -E 's/[0-9]+([A-Za-z])?/\1/')
          if [ -n "$LETTER" ]; then
            # Convert letter to number: A=0, B=1, C=2, etc.
            MINOR=$(python3 -c "print(ord('$LETTER'.upper()) - ord('A'))")
          else
            MINOR=0
          fi
          
          VERSION="${MAJOR}.${MINOR}.0"
          echo "Checking PyPI for version: $VERSION"
          
          # Query PyPI for the version; 200 means it already exists
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://pypi.org/pypi/blockdevice/$VERSION/json" || echo "000")
          
          if [ "$STATUS" = "200" ]; then
            echo "Version $VERSION already exists on PyPI; skipping build"
            echo "version_exists=true" >> "$GITHUB_OUTPUT"
            echo "should_build=false" >> "$GITHUB_OUTPUT"
          else
            echo "Version $VERSION does not exist on PyPI; proceeding with build"
            echo "version_exists=false" >> "$GITHUB_OUTPUT"
            echo "should_build=true" >> "$GITHUB_OUTPUT"
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      # The numeric package version is determined in the build job using
      # scripts/get_version.py; removing the set_version step keeps the
      # ensure-tag job focused on tagging only and avoids cross-job
      # heredoc/python invocation complexity.

  build:
    runs-on: ubuntu-latest
    needs:
      - ensure-tag
    if: needs.ensure-tag.outputs.should_build == 'true' && needs.ensure-tag.outputs.version_exists == 'false'
    outputs:
      blockdevice_version: ${{ steps.get_version.outputs.blockdevice_version }}
      release_display_name: ${{ steps.get_version.outputs.release_display_name }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake build-essential libfuse-dev pkg-config

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pybind11

      - name: Log build reason
        run: |
          echo "Building because:"
          echo "  - Version candidate found: ${{ needs.ensure-tag.outputs.candidate_version }}"
          echo "  - Version does not exist on PyPI"
          echo "  - Proceeding with build and publish"

      - name: Determine package version
        id: get_version
        run: |
          set -euo pipefail
          python -c "from scripts.get_version import get_blockdevice_version,get_release_display_name; print(get_blockdevice_version()); print(get_release_display_name())" > /tmp/_vers
          echo "blockdevice_version=$(sed -n '1p' /tmp/_vers)" >> "$GITHUB_OUTPUT"
          echo "release_display_name=$(sed -n '2p' /tmp/_vers)" >> "$GITHUB_OUTPUT"

      - name: Log resolved version
        run: |
          set -euo pipefail
          echo "Resolved BLOCKDEVICE_VERSION=${{ steps.get_version.outputs.blockdevice_version }}"
          echo "Resolved RELEASE_DISPLAY_NAME=${{ steps.get_version.outputs.release_display_name }}"
          # Append to the GitHub Actions job summary for quick visibility
          if [ -n "${GITHUB_STEP_SUMMARY-}" ]; then
            echo "### Blockdevice version info" >> "$GITHUB_STEP_SUMMARY"
            echo "* BLOCKDEVICE_VERSION: ${{ steps.get_version.outputs.blockdevice_version }}" >> "$GITHUB_STEP_SUMMARY"
            echo "* RELEASE_DISPLAY_NAME: ${{ steps.get_version.outputs.release_display_name }}" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Build release distributions
        run: |
          set -euo pipefail
          # Clean any previous build artifacts so we don't upload stale packages
          rm -rf dist || true
          python -m pip install --upgrade build
          python -m build

      - name: Upload distributions
        uses: actions/upload-artifact@v4
        with:
          name: release-dists
          path: dist/

  pypi-publish:
    runs-on: ubuntu-latest
    needs:
      - ensure-tag
      - build
    if: needs.build.result == 'success' && needs.ensure-tag.outputs.version_exists == 'false'

    # Dedicated environments with protections for publishing are strongly recommended.
    # For more information, see: https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment#deployment-protection-rules
    environment:
      name: pypi
      # OPTIONAL: uncomment and update to include your PyPI project URL in the deployment status:
      url: https://pypi.org/p/blockdevice
      #
      # ALTERNATIVE: if your GitHub Release name is the PyPI project version string
      # ALTERNATIVE: exactly, uncomment the following line instead:
      # url: https://pypi.org/project/blockdevice/${{ github.event.release.name }}

    permissions:
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Determine version and check PyPI
        id: check_pypi
        run: |
          set -euo pipefail
          # Prefer the canonical version discovered during the build job.
          if [ -n "${{ needs.build.outputs.blockdevice_version }}" ]; then
            VER="${{ needs.build.outputs.blockdevice_version }}"
            echo "Using version from build job: $VER"
          else
            # Fall back to inferring from the sdist filename
            SDIST=$(ls dist/*.tar.gz 2>/dev/null | head -n 1 || true)
            if [ -z "$SDIST" ]; then
              echo "No sdist found in dist/; cannot determine version" >&2
              echo "skip_publish=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            FNAME=$(basename "$SDIST")
            VER=$(echo "$FNAME" | sed -E 's/^blockdevice[-_]?//i; s/\.tar\.gz$//')
          fi
          echo "version=$VER" >> "$GITHUB_OUTPUT"
          echo "Version to publish: $VER"

          # Query PyPI for the version; 200 means it already exists.
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://pypi.org/pypi/blockdevice/$VER/json" || true)
          if [ "$STATUS" = "200" ]; then
            echo "Version $VER already exists on PyPI; skipping publish"
            echo "skip_publish=true" >> "$GITHUB_OUTPUT"
          else
            echo "skip_publish=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Clean dist directory
        if: steps.check_pypi.outputs.skip_publish != 'true'
        run: |
          set -euo pipefail
          rm -rf dist || true

      - name: Retrieve release distributions
        if: steps.check_pypi.outputs.skip_publish != 'true'
        uses: actions/download-artifact@v4
        with:
          name: release-dists
          path: dist/

      - name: Select latest artifact and prune others
        if: steps.check_pypi.outputs.skip_publish != 'true'
        run: |
          set -euo pipefail
          echo "Listing dist contents before selection:"
          ls -l dist || true

          # Find newest sdist by modification time
          SDIST=$(ls -t dist/*.tar.gz 2>/dev/null | head -n 1 || true)
          if [ -z "$SDIST" ]; then
            echo "No sdist found in dist/; nothing to publish" >&2
            ls -l dist || true
            exit 1
          fi

          echo "Selected sdist: $SDIST"
          FNAME=$(basename "$SDIST")
          # Normalize project name prefix and strip .tar.gz to obtain version
          VER=$(echo "$FNAME" | sed -E 's/^blockdevice[-_]?//i; s/\.tar\.gz$//')
          echo "Determined version: $VER"

          # Remove other sdists not matching the selected version
          for f in dist/*.tar.gz; do
            if [ -f "$f" ] && [ "$f" != "$SDIST" ]; then
              echo "Removing extra sdist: $f"
              rm -f "$f"
            fi
          done

          echo "dist/ contents after pruning:"
          ls -l dist || true

      - name: Prune wheels by METADATA Version
        if: steps.check_pypi.outputs.skip_publish != 'true'
        env:
          SELECTED_VER: ${{ steps.check_pypi.outputs.version }}
        run: |
          set -euo pipefail
          python scripts/prune_wheels.py

      - name: Publish to PyPI (OIDC)
        if: steps.check_pypi.outputs.skip_publish != 'true'
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: dist/